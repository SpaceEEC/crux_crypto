#include "erl_nif.h"

#define SODIUM_STATIC 1
#define SODIUM_EXPORT

#include <sodium.h>

static int load(ErlNifEnv *caller_env, void **priv_data, ERL_NIF_TERM load_info) {
  // Initial call returns 0, if successful
  if (sodium_init() < 0) {
    return 1;
  }
  return 0;
}

static int upgrade(ErlNifEnv *caller_env, void **priv_data, void **old_priv_data, ERL_NIF_TERM load_info) {
  // Further calls return 1
  if (sodium_init() < 0) {
    return 1;
  }
  return 0;
}

/**
 * Creates a bad arg exception with `atom_name` as reason.
 * The returned term should be returned to the nif caller.
 */
static ERL_NIF_TERM raise_badarg(ErlNifEnv *env, const char const *atom_name) {
    return enif_raise_exception(env, enif_make_tuple2(env, enif_make_atom(env, "badarg"), enif_make_atom(env, atom_name)));
}

/*
 * argv[0] - amount of bytes to generate
 * returns the generated bytes as a binary
 */
static ERL_NIF_TERM crux_randombytes_buf(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]) {
  ERL_NIF_TERM random_bytes;

  int size;
  if (!enif_get_uint(env, argv[0], &size)) {
    return enif_make_badarg(env);
  }

  unsigned char *data = enif_make_new_binary(env, size, &random_bytes);

  randombytes_buf(data, size);

  return random_bytes;
}

/**
 * argv[0] - message to encrypt
 * argv[1] - key for the encryption
 * argv[2] - nonce for the encryption
 * returns the encrypted binary
 */
static ERL_NIF_TERM crux_crypto_secretbox_easy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]) {
  ErlNifBinary message;
  ErlNifBinary key;
  ErlNifBinary nonce;

  ERL_NIF_TERM encrypted_message;

  if (!enif_inspect_binary(env, argv[0], &message)) {
    return raise_badarg(env, "message");
  }
  if (!enif_inspect_binary(env, argv[1], &key)) {
    return raise_badarg(env, "key");
  }
  if (key.size != crypto_secretbox_KEYBYTES) {
    return raise_badarg(env, "keybytes");
  }
  if (!enif_inspect_binary(env, argv[2], &nonce)) {
    return raise_badarg(env, "nonce");
  }
  if (nonce.size != crypto_secretbox_NONCEBYTES) {
    return raise_badarg(env, "noncebytes");
  }

  unsigned long long size = message.size + crypto_secretbox_MACBYTES;

  unsigned char *encrypted_message_data = enif_make_new_binary(env, size, &encrypted_message);

 // Always returns 0
  crypto_secretbox_easy(encrypted_message_data, message.data, message.size, nonce.data, key.data);

  return encrypted_message;
}

/**
 * argv[0] - message to decrypt
 * argv[1] - key for the decryption
 * argv[2] - nonce for the decryption
 * returns the decrypted binary
 */
static ERL_NIF_TERM crux_crypto_secretbox_open_easy(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]) {
  ErlNifBinary message;
  ErlNifBinary key;
  ErlNifBinary nonce;

  ERL_NIF_TERM decrypted_message;

  if (!enif_inspect_binary(env, argv[0], &message)) {
    return raise_badarg(env, "message");
  }
  if (message.size < crypto_secretbox_MACBYTES) {
    return raise_badarg(env, "messagebytes");
  }
  if (!enif_inspect_binary(env, argv[1], &key)) {
    return raise_badarg(env, "key");
  }
  if (key.size != crypto_secretbox_KEYBYTES) {
    return raise_badarg(env, "keybytes");
  }
  if (!enif_inspect_binary(env, argv[2], &nonce)) {
    return raise_badarg(env, "nonce");
  }
  if (nonce.size != crypto_secretbox_NONCEBYTES) {
    return raise_badarg(env, "noncebytes");
  }

  unsigned long long size = message.size - crypto_secretbox_MACBYTES;

  unsigned char *decrypted_message_data = enif_make_new_binary(env, size, &decrypted_message);

  if (crypto_secretbox_open_easy(decrypted_message_data, message.data, message.size, nonce.data, key.data)) {
    return enif_make_atom(env, "error");
  }

  return enif_make_tuple2(env, enif_make_atom(env, "ok"), decrypted_message);
}

/**
 * argv[0] - message
 * argv[1] - signature
 * argv[2] - public key
 * returns whether the signature was successfully verified
 */ 
static ERL_NIF_TERM crux_crypto_sign_verify_detached(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]) {
  ErlNifBinary message;
  ErlNifBinary signature;
  ErlNifBinary public_key;

  if (!enif_inspect_binary(env, argv[0], &message)) {
    return raise_badarg(env, "message");
  }
  if (!enif_inspect_binary(env, argv[1], &signature)) {
    return raise_badarg(env, "signature");
  }
  if (signature.size != crypto_sign_BYTES) {
    return raise_badarg(env, "signaturebytes");
  }
  if (!enif_inspect_binary(env, argv[2], &public_key)) {
    return raise_badarg(env, "public_key");
  }
  if (public_key.size != crypto_sign_PUBLICKEYBYTES) {
    return raise_badarg(env, "public_keybytes");
  }

  if (crypto_sign_verify_detached(signature.data, message.data, message.size, public_key.data)) {
    return enif_make_atom(env, "error");
  }

  return enif_make_atom(env, "ok");
}

static ErlNifFunc nifs[] = {
  {"randombytes_buf", 1, crux_randombytes_buf},
  {"crypto_secretbox_easy", 3, crux_crypto_secretbox_easy},
  {"crypto_secretbox_open_easy", 3, crux_crypto_secretbox_open_easy},
  {"crypto_sign_verify_detached", 3, crux_crypto_sign_verify_detached}
};

ERL_NIF_INIT(Elixir.Crux.Crypto, nifs, load, NULL, upgrade, NULL)